"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const push_status_1 = require("../push-status");
const miscellaneous_1 = require("../../../utils/miscellaneous");
const remotes = {
    getPush: jest.fn(),
    getRemotesList: jest.fn(),
};
jest.mock('../../../utils/miscellaneous');
jest.mock('colorette', () => ({
    green: (str) => str,
    yellow: (str) => str,
    red: (str) => str,
    gray: (str) => str,
    magenta: (str) => str,
    cyan: (str) => str,
}));
jest.mock('../../api', () => (Object.assign(Object.assign({}, jest.requireActual('../../api')), { ReuniteApiClient: jest.fn().mockImplementation(function (...args) {
        this.remotes = remotes;
    }) })));
describe('handlePushStatus()', () => {
    const mockConfig = { apis: {} };
    const pushResponseStub = {
        hasChanges: true,
        status: {
            preview: {
                scorecard: [],
                deploy: {
                    url: 'https://test-url',
                    status: 'success',
                },
            },
            production: {
                scorecard: [],
                deploy: {
                    url: 'https://test-url',
                    status: 'success',
                },
            },
        },
    };
    beforeEach(() => {
        jest.spyOn(process.stderr, 'write').mockImplementation(() => true);
        jest.spyOn(process.stdout, 'write').mockImplementation(() => true);
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    it('should throw error if organization not provided', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, push_status_1.handlePushStatus)({
            domain: 'test-domain',
            organization: '',
            project: 'test-project',
            pushId: 'test-push-id',
            'max-execution-time': 1000,
        }, mockConfig);
        expect(miscellaneous_1.exitWithError).toHaveBeenCalledWith("No organization provided, please use --organization option or specify the 'organization' field in the config file.");
    }));
    it('should return success push status for preview-build', () => __awaiter(void 0, void 0, void 0, function* () {
        process.env.REDOCLY_AUTHORIZATION = 'test-api-key';
        remotes.getPush.mockResolvedValueOnce(pushResponseStub);
        yield (0, push_status_1.handlePushStatus)({
            domain: 'test-domain',
            organization: 'test-org',
            project: 'test-project',
            pushId: 'test-push-id',
            'max-execution-time': 1000,
        }, mockConfig);
        expect(process.stdout.write).toHaveBeenCalledTimes(1);
        expect(process.stdout.write).toHaveBeenCalledWith('ðŸš€ PREVIEW deployment succeeded.\nPreview URL: https://test-url\n');
    }));
    it('should return success push status for preview and production builds', () => __awaiter(void 0, void 0, void 0, function* () {
        process.env.REDOCLY_AUTHORIZATION = 'test-api-key';
        remotes.getPush.mockResolvedValue(Object.assign(Object.assign({}, pushResponseStub), { isMainBranch: true }));
        yield (0, push_status_1.handlePushStatus)({
            domain: 'test-domain',
            organization: 'test-org',
            project: 'test-project',
            pushId: 'test-push-id',
            'max-execution-time': 1000,
        }, mockConfig);
        expect(process.stdout.write).toHaveBeenCalledTimes(2);
        expect(process.stdout.write).toHaveBeenCalledWith('ðŸš€ PREVIEW deployment succeeded.\nPreview URL: https://test-url\n');
        expect(process.stdout.write).toHaveBeenCalledWith('ðŸš€ PRODUCTION deployment succeeded.\nPreview URL: https://test-url\n');
    }));
    it('should return failed push status for preview build', () => __awaiter(void 0, void 0, void 0, function* () {
        process.env.REDOCLY_AUTHORIZATION = 'test-api-key';
        remotes.getPush.mockResolvedValue({
            isOutdated: false,
            hasChanges: true,
            status: {
                preview: { deploy: { status: 'failed', url: 'https://test-url' }, scorecard: [] },
            },
        });
        yield (0, push_status_1.handlePushStatus)({
            domain: 'test-domain',
            organization: 'test-org',
            project: 'test-project',
            pushId: 'test-push-id',
            'max-execution-time': 1000,
        }, mockConfig);
        expect(miscellaneous_1.exitWithError).toHaveBeenCalledWith('âŒ PREVIEW deployment failed.\nPreview URL: https://test-url');
    }));
    it('should return success push status for preview build and print scorecards', () => __awaiter(void 0, void 0, void 0, function* () {
        process.env.REDOCLY_AUTHORIZATION = 'test-api-key';
        remotes.getPush.mockResolvedValue({
            isOutdated: false,
            hasChanges: true,
            status: {
                preview: {
                    deploy: { status: 'success', url: 'https://test-url' },
                    scorecard: [
                        {
                            name: 'test-name',
                            status: 'success',
                            description: 'test-description',
                            url: 'test-url',
                        },
                    ],
                },
            },
        });
        yield (0, push_status_1.handlePushStatus)({
            domain: 'test-domain',
            organization: 'test-org',
            project: 'test-project',
            pushId: 'test-push-id',
            'max-execution-time': 1000,
        }, mockConfig);
        expect(process.stdout.write).toHaveBeenCalledTimes(4);
        expect(process.stdout.write).toHaveBeenCalledWith('ðŸš€ PREVIEW deployment succeeded.\nPreview URL: https://test-url\n');
        expect(process.stdout.write).toHaveBeenCalledWith('\nScorecard:');
        expect(process.stdout.write).toHaveBeenCalledWith('\n    Name: test-name\n    Status: success\n    URL: test-url\n    Description: test-description\n');
        expect(process.stdout.write).toHaveBeenCalledWith('\n');
    }));
    it('should display message if there is no changes', () => __awaiter(void 0, void 0, void 0, function* () {
        process.env.REDOCLY_AUTHORIZATION = 'test-api-key';
        remotes.getPush.mockResolvedValueOnce({
            isOutdated: false,
            hasChanges: false,
            status: {
                preview: { deploy: { status: 'skipped', url: 'https://test-url' }, scorecard: [] },
            },
        });
        yield (0, push_status_1.handlePushStatus)({
            domain: 'test-domain',
            organization: 'test-org',
            project: 'test-project',
            pushId: 'test-push-id',
            wait: true,
            'max-execution-time': 1000,
        }, mockConfig);
        expect(process.stderr.write).toHaveBeenCalledWith('Files not uploaded. Reason: no changes.\n');
    }));
});
