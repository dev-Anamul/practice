"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlePushStatus = void 0;
const colors = require("colorette");
const miscellaneous_1 = require("../../utils/miscellaneous");
const spinner_1 = require("../../utils/spinner");
const utils_1 = require("../utils");
const colorette_1 = require("colorette");
const api_1 = require("../api");
const INTERVAL = 5000;
function handlePushStatus(argv, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const startedAt = performance.now();
        const spinner = new spinner_1.Spinner();
        const { organization, project: projectId, pushId, wait } = argv;
        const orgId = organization || config.organization;
        if (!orgId) {
            return (0, miscellaneous_1.exitWithError)(`No organization provided, please use --organization option or specify the 'organization' field in the config file.`);
        }
        const domain = argv.domain || (0, api_1.getDomain)();
        if (!domain) {
            return (0, miscellaneous_1.exitWithError)(`No domain provided, please use --domain option or environment variable REDOCLY_DOMAIN.`);
        }
        const maxExecutionTime = argv['max-execution-time'] || 600;
        try {
            const apiKey = (0, api_1.getApiKeys)(domain);
            const client = new api_1.ReuniteApiClient(domain, apiKey);
            if (wait) {
                const push = yield waitForDeployment(client, 'preview');
                if (push.isMainBranch && push.status.preview.deploy.status === 'success') {
                    yield waitForDeployment(client, 'production');
                }
                printPushStatusInfo();
                return;
            }
            const pushPreview = yield getAndPrintPushStatus(client, 'preview');
            printScorecard(pushPreview.status.preview.scorecard);
            if (pushPreview.isMainBranch) {
                yield getAndPrintPushStatus(client, 'production');
                printScorecard(pushPreview.status.production.scorecard);
            }
            printPushStatusInfo();
        }
        catch (err) {
            const message = err instanceof utils_1.DeploymentError
                ? err.message
                : `‚úó Failed to get push status. Reason: ${err.message}\n`;
            (0, miscellaneous_1.exitWithError)(message);
        }
        function printPushStatusInfo() {
            process.stderr.write(`\nProcessed push-status for ${colors.yellow(orgId)}, ${colors.yellow(projectId)} and pushID ${colors.yellow(pushId)}.\n`);
            (0, miscellaneous_1.printExecutionTime)('push-status', startedAt, 'Finished');
        }
        function waitForDeployment(client, buildType) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((resolve, reject) => {
                    if (performance.now() - startedAt > maxExecutionTime * 1000) {
                        spinner.stop();
                        reject(new Error(`Time limit exceeded.`));
                    }
                    getAndPrintPushStatus(client, buildType)
                        .then((push) => {
                        if (!['pending', 'running'].includes(push.status[buildType].deploy.status)) {
                            printScorecard(push.status[buildType].scorecard);
                            resolve(push);
                            return;
                        }
                        setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                            try {
                                const pushResponse = yield waitForDeployment(client, buildType);
                                resolve(pushResponse);
                            }
                            catch (e) {
                                reject(e);
                            }
                        }), INTERVAL);
                    })
                        .catch(reject);
                });
            });
        }
        function getAndPrintPushStatus(client, buildType) {
            return __awaiter(this, void 0, void 0, function* () {
                const push = yield client.remotes.getPush({
                    organizationId: orgId,
                    projectId,
                    pushId,
                });
                if (push.isOutdated || !push.hasChanges) {
                    process.stderr.write((0, colorette_1.yellow)(`Files not uploaded. Reason: ${push.isOutdated ? 'outdated' : 'no changes'}.\n`));
                }
                else {
                    displayDeploymentAndBuildStatus({
                        status: push.status[buildType].deploy.status,
                        previewUrl: push.status[buildType].deploy.url,
                        buildType,
                        spinner,
                        wait,
                    });
                }
                return push;
            });
        }
    });
}
exports.handlePushStatus = handlePushStatus;
function printScorecard(scorecard) {
    if (!scorecard.length) {
        return;
    }
    process.stdout.write(`\n${colors.magenta('Scorecard')}:`);
    for (const scorecardItem of scorecard) {
        process.stdout.write(`
    ${colors.magenta('Name')}: ${scorecardItem.name}
    ${colors.magenta('Status')}: ${scorecardItem.status}
    ${colors.magenta('URL')}: ${colors.cyan(scorecardItem.url)}
    ${colors.magenta('Description')}: ${scorecardItem.description}\n`);
    }
    process.stdout.write(`\n`);
}
function displayDeploymentAndBuildStatus({ status, previewUrl, spinner, buildType, wait, }) {
    switch (status) {
        case 'success':
            spinner.stop();
            return process.stdout.write(`${colors.green(`üöÄ ${buildType.toLocaleUpperCase()} deployment succeeded.`)}\n${colors.magenta('Preview URL')}: ${colors.cyan(previewUrl)}\n`);
        case 'failed':
            spinner.stop();
            throw new utils_1.DeploymentError(`${colors.red(`‚ùå ${buildType.toLocaleUpperCase()} deployment failed.`)}\n${colors.magenta('Preview URL')}: ${colors.cyan(previewUrl)}`);
        case 'pending':
            return wait
                ? spinner.start(`${colors.yellow(`Pending ${buildType}`)}`)
                : process.stdout.write(`Status: ${colors.yellow(`Pending ${buildType}`)}\n`);
        case 'skipped':
            spinner.stop();
            return process.stdout.write(`${colors.yellow(`Skipped ${buildType}`)}\n`);
        case 'running':
            return wait
                ? spinner.start(`${colors.yellow(`Running ${buildType}`)}`)
                : process.stdout.write(`Status: ${colors.yellow(`Running ${buildType}`)}\n`);
    }
}
